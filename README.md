# Rebo - A statically-typed rust-inspired scripting language

Rebo is an expression-based scripting language with syntax heavily inspired by rust.
It is statically typed and has backwards type inference.
When executing a script, rebo fully analyses and checks the source code
including all types, before it runs.
While that approach is usually used for AOT (Ahead Of Time compilers),
the execution of rebo is interpreted and thus embeddable on all systems.
This approach also allows defining types and functions after their first use.

## Resources

* **book / documentation:** <https://rebo.oberien.de/book/>.
* **playground:** <https://rebo.oberien.de/>.

## Running

* Make sure to have rust installed.
  If you don't have it installed already, follow the guide on <https://rustup.rs/>.
* Clone this repository and navigate into the directory (`git clone https://github.com/oberien/rebo; cd rebo`)
* Run a rebo file: `cargo run --release test.re`

## Embedding

to be documented:
* rust-functions (struct / enum as arg / ret, methods, primitive-methods, generics)
* required rebo functions

# TODOs:

### Current Limitations
* BoolNot has lower precedence than comparison operations
* intermediate method calls in assignments not allowed: `foo.get().bar = 5` doesn't work, `let bar = foo.get(); bar.bar = 5` does
* no expression-field/method-access - methods / fields can only be called / accessed on variables (not expressions)
    * for example, you can't write `1.to_float()` but instead need to write `let i = 1; i.to_float()`
* no recursive patterns: `match foo { Foo::Foo(Bar::Bar(baz)) => ... }`
* pathological format strings: `f"{f"{"{"}"}"`
* bad unification of generic functions as first-class citizens
* unsure if multiple types on a typeck-node should be an error
* no proper garbage collection, just Arc (i.e. reference cycles will be leaked)

### Planned Features
* generators
* destructuring: `let Foo { bar, baz } = foo`
* non-duplicate field initialization: `Foo { bar }` instead of `Foo { bar: bar }`
* `default()`
* `Rng::gen()`
* stdlib docs, autogenerated docs
* traits, generic traits, associated types, iterator-trait
* proper module system
* tuples: `(1, "foo")`
* generic wildcard
* proper ranges
* forbid or implement never-type and varargs
* proper mutability
* unused warnings: struct-fields, enum-variants, bindings, functions
* casing warnings: statics, binds, functions, types
* int bit-ops (and, or, xor, -assign)
* detect and error against circular static instantiations: `static FOO = BAR; static BAR = FOO`
* improve bottom-handling in typeck (`Constraint::PropagatingBottom`): `fn foo() -> i32 { return 42; }`

### Internal Improvements
* Regex caching / interning
* String interning / Cow / &str optimization
* fix existing unit tests and add more

### Unit tests to add

```rs
// shall not ICE - shall result in UnknownEnum diagnostic
match field {
    Foo::Empty => (),
}
```
